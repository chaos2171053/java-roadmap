package org.example.LinkedList;

import java.util.PriorityQueue;

//给你一个链表数组，每个链表都已经按升序排列。
//
//请你将所有链表合并到一个升序链表中，返回合并后的链表。
public class MergeKSortedLists {
    public ListNode mergeKLists(ListNode[] lists) {
        if (lists.length == 0) return null;
        // 虚拟头结点
        ListNode dummy = new ListNode(-1);
        ListNode p = dummy;
        // 优先级队列，最小堆
        PriorityQueue<ListNode> pq = new PriorityQueue<>(
                lists.length, (a, b)->(a.val - b.val));

        // 将 k 个链表的头结点加入最小堆
        for (ListNode head : lists) {
            if (head != null)
                pq.add(head);
        }

        while (!pq.isEmpty()) {
            // 获取最小节点，接到结果链表中
            ListNode node = pq.poll();
            p.next = node;
            if (node.next != null) {
                pq.add(node.next);
            }
            // p 指针不断前进
            p = p.next;
        }
        return dummy.next;
    }
}

// 利用了优先级队列（PriorityQueue）来合并 k 个有序链表
//虚拟头结点：首先创建一个虚拟头结点 dummy，它的值可以是任意的，这个头结点会作为结果链表的头部。
//
//优先级队列：我们创建一个优先级队列 PriorityQueue，用于存放链表的头结点。优先级队列是一个最小堆，它会根据节点的值自动进行排序，确保队列头部始终是最小的节点。我们会利用这个特性来不断取出最小的节点。
//
//初始化优先级队列：将 k 个链表的头结点加入优先级队列。由于题目中说每个链表都已经按升序排列，因此每个链表的头结点都是各自链表的最小值。
//
//循环合并：进入循环，不断地从优先级队列中取出最小节点，将其接到结果链表中。如果被取出节点的下一个节点不为空，则将其下一个节点加入优先级队列，保持队列的有序性。这样做的效果就是每次从优先级队列中取出的节点都是当前 k 个链表中最小的节点。
//
//返回结果：循环结束后，所有节点都被正确地连接到了结果链表中，只需返回结果链表的头结点即可。


//首先，我们有三个已排序的链表，分别是：
//
//lists[0]: 1 -> 4 -> 5
//lists[1]: 1 -> 3 -> 4
//lists[2]: 2 -> 6

//接下来我们初始化一个优先级队列，队列中存放每个链表的头结点，按照头结点的值进行排序。初始状态如下：
//
//优先级队列：
//1 -> 4 -> 5
//1 -> 3 -> 4
//2 -> 6

//现在开始循环合并：
//
//首先，从优先级队列中取出值最小的节点 1，并将其接到结果链表中。因为 1 的下一个节点是 4，所以将 4 加入优先级队列。

//结果链表：1
//    优先级队列：4 -> 5
//              1 -> 3 -> 4
//              2 -> 6

//接下来，从优先级队列中取出值最小的节点 1，并将其接到结果链表中。因为 1 的下一个节点是 3，所以将 3 加入优先级队列。
//结果链表：1 -> 1
//优先级队列：4 -> 5
//          3 -> 4
//          2 -> 6

//继续，从优先级队列中取出值最小的节点 2，并将其接到结果链表中。因为 2 的下一个节点是 6，所以将 6 加入优先级队列。

//结果链表：1 -> 1 -> 2
//优先级队列：4 -> 5
//          3 -> 4
//          6

// 依次类推，得到 1 -> 1 -> 2 -> 3 -> 4 -> 4-> 5 -> 6